<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neko BTC — Mint</title>
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='favicon-32.png') }}">
  <script src="{{ url_for('static', filename='sats-connect-bundle.js') }}"></script>
  <!-- hCaptcha loader -->
  <script src="https://js.hcaptcha.com/1/api.js" async defer></script>
  <!-- Kawaii display + rounded JP font -->
  <link href="https://fonts.googleapis.com/css2?family=Rampart+One&family=Zen+Maru+Gothic:wght@500;700&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg-pink: #ff66a3;
      --bg-pink-deep: #ff4d95;
      --neon-teal: #7efcff;
      --lav: #d9b3ff;
      --ink: #0b1020;
      --chip: #111832;
      --chip-2: #0d1430;
      --white: #fff;
      --soft: rgba(255, 255, 255, .75);
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background:
        radial-gradient(60vmax 60vmax at 20% 15%, #ffd3e8 0%, transparent 60%),
        radial-gradient(70vmax 70vmax at 80% 80%, #ffc2ea 0%, transparent 55%),
        linear-gradient(140deg, var(--bg-pink) 0%, var(--bg-pink-deep) 60%, #ff2e85 100%);
      color: var(--white);
      display: grid;
      place-items: center;
      min-height: 100svh;
      overflow-x: hidden;
      font-family: "Zen Maru Gothic", ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
      letter-spacing: .2px;
    }

    .container {
      text-align: center;
      width: min(92vw, 760px);
      position: relative;
      z-index: 1;
    }

    header h1 {
      font-family: "Rampart One", system-ui;
      margin: 18px 0 6px;
      font-size: clamp(32px, 6vw, 64px);
      line-height: 1.05;
      letter-spacing: .5px;
      background: linear-gradient(90deg, var(--neon-teal), var(--lav), var(--white));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      -webkit-text-stroke: 1px rgba(10, 15, 35, .6);
      text-shadow: 0 0 1px rgba(0, 0, 0, .4), 0 2px 12px rgba(126, 252, 255, .4), 0 0 40px rgba(217, 179, 255, .18);
    }

    header .tag {
      font-size: clamp(12px, 2.8vw, 16px);
      margin-top: 4px;
      color: rgba(255, 255, 255, .9);
      display: inline-flex;
      align-items: center;
      gap: .5ch;
      padding: 6px 12px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .08), rgba(255, 255, 255, .03));
      border: 1px solid rgba(255, 255, 255, .18);
      box-shadow: 0 6px 24px rgba(0, 0, 0, .18), inset 0 1px 0 rgba(255, 255, 255, .15);
      backdrop-filter: blur(6px);
    }

    .counter {
      margin-top: 10px;
      font-weight: 700;
      font-size: clamp(14px, 3.2vw, 18px);
      color: var(--neon-teal);
      text-shadow: 0 0 12px rgba(126, 252, 255, .55);
    }

    .btn {
      margin-top: 14px;
      padding: 14px 22px;
      border-radius: 999px;
      font-weight: 800;
      font-size: 16px;
      letter-spacing: .4px;
      cursor: pointer;
      color: #0a1328;
      background: linear-gradient(180deg, #c8fff8, #9ef4f1);
      border: 1px solid #8ee8e5;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .22), 0 0 0 4px rgba(126, 252, 255, .18), inset 0 1px 0 rgba(255, 255, 255, .8);
      transition: transform .08s ease, filter .15s ease, box-shadow .2s ease;
    }

    .btn+.btn {
      margin-left: 10px;
    }

    .btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.03);
    }

    .btn:active {
      transform: translateY(0);
      filter: brightness(.98);
    }

    .btn:disabled {
      opacity: .6;
      cursor: not-allowed;
      filter: saturate(.6) brightness(.95);
    }

    .image-wrap {
      margin: 20px auto 10px;
      width: 340px;
      height: 340px;
      max-width: 90vw;
      max-height: 90vw;
      padding: 10px;
      border-radius: 28px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .25), rgba(255, 255, 255, .05));
      border: 1px solid rgba(255, 255, 255, .22);
      box-shadow: 0 10px 30px rgba(0, 0, 0, .25), 0 0 0 6px rgba(126, 252, 255, .08), 0 0 40px rgba(217, 179, 255, .18);
      backdrop-filter: blur(6px);
    }

    .image-container {
      position: relative;
      display: grid;
      place-items: center;
      overflow: hidden;
      width: 100%;
      height: 100%;
      border-radius: 20px;
      background: radial-gradient(120% 120% at 50% 0%, var(--chip) 0%, var(--chip-2) 60%, #0a0f26 100%);
      border: 1px solid rgba(126, 252, 255, .18);
      box-shadow: inset 0 8px 30px rgba(0, 0, 0, .45);
    }

    .image-container::after {
      content: "";
      position: absolute;
      inset: 8px;
      border-radius: 16px;
      border: 2px solid rgba(126, 252, 255, .15);
      pointer-events: none;
      box-shadow: inset 0 0 22px rgba(126, 252, 255, .15), inset 0 0 55px rgba(217, 179, 255, .08);
    }

    #randomImage {
      width: 100%;
      height: 100%;
      object-fit: contain;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      transition: opacity .5s ease, transform .25s ease;
      filter: drop-shadow(0 2px 0 rgba(255, 255, 255, .35)) drop-shadow(0 0 18px rgba(126, 252, 255, .25));
    }

    .loaded {
      opacity: 1;
      transform: scale(1);
    }

    #randomImage:not(.loaded) {
      opacity: 0;
      transform: scale(.985);
    }

    #addressDisplay {
      margin-top: 10px;
      font-size: .95rem;
      color: var(--soft);
      word-break: break-all;
    }

    #status {
      margin-top: 10px;
      min-height: 1.2em;
      color: var(--white);
      text-shadow: 0 0 10px rgba(126, 252, 255, .25);
      font-weight: 700;
    }

    .flyer-container {
      position: fixed;
      inset: 0;
      overflow: hidden;
      z-index: 0;
      pointer-events: none;
    }

    .flyer {
      position: absolute;
      width: 128px;
      height: 128px;
      object-fit: contain;
      image-rendering: pixelated;
      animation: flyAcross 12s linear infinite;
      opacity: .7;
      filter: drop-shadow(0 0 12px rgba(255, 255, 255, .18));
    }

    @keyframes flyAcross {
      0% {
        transform: translateX(-140px) translateY(var(--y, 0px)) rotate(0deg);
      }

      100% {
        transform: translateX(calc(100vw + 140px)) translateY(var(--y, 0px)) rotate(360deg);
      }
    }

    .subtagline {
      margin-top: 8px;
      font-size: clamp(12px, 2.6vw, 15px);
      color: rgba(255, 255, 255, .88);
      text-shadow: 0 0 10px rgba(217, 179, 255, .22);
      letter-spacing: .4px;
    }

    .h-captcha {
      display: inline-block;
    }
  </style>
</head>

<body>
  <div class="flyer-container" id="flyerContainer"></div>
  <div class="container">
    <header>
      <h1>ねNEKOこ ねNEKOこ</h1>
      <div class="tag">ねこねこ · Mint Page</div>
      <div class="subtagline">Kawaii Bitcoin inscriptions — one purr at a time</div>
      <div class="counter" id="supplyCounter">10,000 / 10,000</div>
    </header>
    <div>
      <button id="claimWLButton" class="btn">Claim WL</button>
      <button id="mintButton" class="btn" disabled>
        <span class="btn-label">Mint</span>
        <span id="mintEtaPill" class="pill">Neko</span>
      </button>
    </div>
    <!-- Invisible hCaptcha widget -->
    <div id="h-captcha" class="h-captcha" data-sitekey="{{ HCAPTCHA_SITE_KEY }}" data-size="invisible"></div>
    <div class="image-wrap">
      <div class="image-container">
        <img id="randomImage" src="" alt="Neko">
      </div>
    </div>
    <div id="addressDisplay"></div>
    <div id="status"></div>
  </div>
  <script>
    // ===== Global state =====
    let reservationId = null;
    let reservedFilename = null;
    let watchTimer = null;
    let slideshowTimer = null;
    let isWLReservation = false;
    let wlInscriptionId = null;
    let hcWidgetId = null;
    let hcReady = false;
    const SLIDESHOW_MS = 5000;
    window.ordinalAddress = null;
    const $id = (x) => document.getElementById(x);
    function setStatus(msg) { $id('status').textContent = msg || ''; }
    function setStatusHTML(html) { document.getElementById('status').innerHTML = html || ''; }

    // === hCaptcha helper ===
    async function ensureHCaptcha() {
      if (hcReady) return;
      while (typeof hcaptcha === 'undefined' || !document.getElementById('h-captcha')) {
        await new Promise(r => setTimeout(r, 50));
      }
      if (hcWidgetId === null) {
        hcWidgetId = hcaptcha.render('h-captcha', {
          sitekey: '{{ HCAPTCHA_SITE_KEY }}',
          size: 'invisible',
        });
      }
      hcReady = true;
    }

    async function getHCToken() {
      await ensureHCaptcha();
      // one widget, executed per need (returns a Promise<string>)
      return hcaptcha.execute(hcWidgetId, { async: true });
    }

    // ===== Supply / slideshow =====
    async function refreshSupply() {
      try {
        const r = await fetch('/supply');
        const j = await r.json();
        const remaining = j.remaining ?? 0;
        const total = j.total ?? 10000;
        $id('supplyCounter').textContent = `${remaining.toLocaleString()} / ${total.toLocaleString()}`;
      } catch { }
    }
    function fadeSwapImage(newUrl) {
      const img = $id('randomImage');
      img.classList.remove('loaded');
      const onLoad = () => { img.classList.add('loaded'); img.removeEventListener('load', onLoad); };
      img.addEventListener('load', onLoad);
      img.crossOrigin = 'anonymous';
      img.src = newUrl;
    }
    async function slideshowTick() {
      try {
        const res = await fetch('/randomize_preview', { method: 'GET', cache: 'no-store' });
        if (!res.ok) throw new Error('Preview HTTP ' + res.status);
        const response = await res.json();
        if (response.imageUrl) fadeSwapImage(response.imageUrl);
      } catch (_) { /* keep silent in UI */ }
    }
    function startSlideshow() {
      if (slideshowTimer) clearInterval(slideshowTimer);
      slideshowTimer = setInterval(slideshowTick, SLIDESHOW_MS);
      slideshowTick();
    }

    // ===== Helper for base64 =====
    async function getImageAsBase64(url) {
      const res = await fetch(url, { cache: 'no-cache' });
      const blob = await res.blob();
      const buf = await blob.arrayBuffer();
      const bytes = new Uint8Array(buf);
      let bin = '';
      for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
      return btoa(bin);
    }

    // ===== Reservation watcher =====
    async function watchReservation() {
      if (!reservationId) return;
      try {
        const token = await getHCToken();
        const r = await fetch('/reservation_status', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reservationId, hCaptchaToken: token })
        });
        const j = await r.json();
        if (!j.ok) {
          setStatus(j.error || 'Failed to check reservation status');
          return;
        }
        if (!j.active) {
          clearInterval(watchTimer); watchTimer = null;
          setStatus('Reservation ended.');
          return;
        }
        if (j.used) {
          clearInterval(watchTimer); watchTimer = null;
          setStatus(`Mint confirmed ✔${isWLReservation ? ' (WL)' : ''}`);
          await refreshSupply();
          return;
        }
      } catch (err) {
        console.error(err);
        setStatus('Error checking reservation: ' + (err.message || 'Unknown error'));
      }
    }

    // ===== Wallet connect and WL logic =====
    function hasBitcoinProvider() {
      if (typeof window.BitcoinProvider === 'undefined') {
        setStatus('Please install Xverse (or a compatible Bitcoin wallet) and refresh.');
        console.error('No BitcoinProvider found.');
        return false;
      }
      return true;
    }
    async function connectWallet() {
      if (!hasBitcoinProvider()) return;
      try {
        const response = await window.BitcoinProvider.request('getAccounts', {
          purposes: ['ordinals'],
          message: 'Connect to check whitelist eligibility',
          network: { type: 'Mainnet' }
        });
        if (response && Array.isArray(response.result)) {
          const addresses = response.result;
          const ord = addresses.find(a => a.purpose === 'ordinals')?.address || null;
          if (ord) {
            window.ordinalAddress = ord;
            $id('addressDisplay').innerHTML = `<strong>Ordinal Address:</strong> ${ord}`;
            return ord;
          } else {
            setStatus('Failed to get Ordinal address from wallet.');
            console.error('No ordinals address found:', response);
            return null;
          }
        } else {
          setStatus('Invalid response from wallet.');
          console.error('Invalid getAccounts response:', response);
          return null;
        }
      } catch (err) {
        console.error(err);
        setStatus('Error connecting: ' + (err.message || 'Unknown error'));
        return null;
      }
    }
    async function claimWL() {
      const btn = $id('claimWLButton');
      btn.disabled = true;
      $id('mintButton').disabled = true;
      setStatus('Connecting wallet…');
      const address = await connectWallet();
      if (!address) {
        btn.disabled = false;
        $id('mintButton').disabled = false;
        return;
      }
      setStatus('Checking whitelist eligibility…');
      try {
        const token = await getHCToken();
        const res = await fetch('/check_wl_eligibility', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ address, hCaptchaToken: token })
        });
        const data = await res.json();
        if (!data.ok || !data.eligible) {
          setStatus(data.error || 'Not eligible for whitelist.');
          btn.disabled = false;
          $id('mintButton').disabled = false;
          return;
        }
        const inscriptionId = data.inscriptions[0];
        setStatus('Claiming whitelist spot…');
        const claimToken = await getHCToken();
        const claimRes = await fetch('/claim_wl', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-Client-Id': crypto.randomUUID() },
          body: JSON.stringify({ address, inscriptionId, hCaptchaToken: claimToken })
        });
        const claim = await claimRes.json();
        if (claim.error && claim.error.includes("Another WL mint is in progress")) {
          setStatus("Another WL mint is in progress. Please wait up to 15 minutes.");
          btn.disabled = false;
          $id('mintButton').disabled = false;
          return;
        }
        if (claim.error && claim.error.includes("Inscription temporarily locked")) {
          setStatus("Inscription locked. Please wait up to 15 minutes.");
          btn.disabled = false;
          $id('mintButton').disabled = false;
          return;
        }
        if (!claim.ok) {
          setStatus(claim.error || 'Failed to claim whitelist spot.');
          btn.disabled = false;
          $id('mintButton').disabled = false;
          return;
        }
        reservationId = claim.reservationId;
        reservedFilename = claim.filename;
        wlInscriptionId = claim.inscriptionId;
        isWLReservation = true;
        fadeSwapImage(claim.imageUrl);
        if (watchTimer) clearInterval(watchTimer);
        watchTimer = setInterval(watchReservation, 5_000);
        setStatus('Whitelist spot reserved! Waiting for mint confirmation (this may take up to 15 minutes)...');
        const prepToken = await getHCToken();
        const prepRes = await fetch('/prepare_wl_inscription', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hCaptchaToken: prepToken })
        });
        const prep = await prepRes.json();
        if (!prep.appFeeAddress || !prep.appFee) {
          setStatus('Server missing WL fee config');
          btn.disabled = false;
          $id('mintButton').disabled = false;
          reservationId = null;
          reservedFilename = null;
          wlInscriptionId = null;
          isWLReservation = false;
          return;
        }
        const base64Image = await getImageAsBase64(`/file/${reservedFilename}`);
        await window.SatsConnect.createInscription({
          payload: {
            network: { type: prep.network || 'Mainnet' },
            contentType: 'image/png',
            content: base64Image,
            payloadType: 'BASE_64',
            appFeeAddress: prep.appFeeAddress,
            appFee: prep.appFee
          },
          onFinish: () => { },
          onCancel: () => { }
        });
        btn.disabled = false;
        $id('mintButton').disabled = false;
      } catch (err) {
        console.error(err);
        setStatus('Error during WL claim: ' + (err.message || 'Unknown error'));
        btn.disabled = false;
        $id('mintButton').disabled = false;
        if (reservationId && reservedFilename && window.ordinalAddress && wlInscriptionId) {
          const cancelToken = await getHCToken();
          fetch('/cancel_wl_reservation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ reservationId, filename: reservedFilename, address: window.ordinalAddress, inscriptionId: wlInscriptionId, hCaptchaToken: cancelToken })
          });
        }
        reservationId = null;
        reservedFilename = null;
        wlInscriptionId = null;
        isWLReservation = false;
      }
    }

    // ===== Mint flow =====
    async function startMintFlow() {
      const btn = $id('mintButton');
      try {
        setStatus('Picking a random Neko…');
        const randToken = await getHCToken();
        const randRes = await fetch('/randomize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hCaptchaToken: randToken })
        });
        if (!randRes.ok) throw new Error('Randomize HTTP ' + randRes.status);
        const rand = await randRes.json();
        const filename = rand?.imageInfo?.background;
        const randomizedUrl = rand?.imageUrl;
        if (!filename) throw new Error('Randomize did not return a filename');
        setStatus('Reserving your Neko…');
        const holdToken = await getHCToken();
        const holdRes = await fetch('/reserve_for_image', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-Client-Id': crypto.randomUUID() },
          body: JSON.stringify({ filename, hCaptchaToken: holdToken })
        });
        const hold = await holdRes.json();
        if (!hold.ok) throw new Error(hold.error || 'Reserve failed');
        reservationId = hold.reservationId;
        reservedFilename = hold.filename || filename;
        const reservedUrl = hold.imageUrl || randomizedUrl;
        isWLReservation = false;
        if (watchTimer) clearInterval(watchTimer);
        watchTimer = setInterval(watchReservation, 5_000);
        await refreshSupply();
        setStatus('Preparing inscription…');
        const prepToken = await getHCToken();
        const prepRes = await fetch('/prepare_inscription', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ hCaptchaToken: prepToken })
        });
        const prep = await prepRes.json();
        if (!prep.appFeeAddress || !prep.appFee) throw new Error('Server missing app fee config');
        if (!window.SatsConnect || typeof window.SatsConnect.createInscription !== 'function') {
          setStatus('Sats-Connect not available. Check sats-connect-bundle.js.');
          btn.disabled = false; return;
        }
        if (!reservedUrl) throw new Error('Reserved image URL missing');
        const base64Image = await getImageAsBase64(reservedUrl);
        setStatus('Opening wallet…');
        await window.SatsConnect.createInscription({
          payload: {
            network: { type: prep.network || 'Mainnet' },
            contentType: 'image/png',
            content: base64Image,
            payloadType: 'BASE_64',
            appFeeAddress: prep.appFeeAddress,
            appFee: prep.appFee
          },
          onFinish: async (resp) => {
            const id =
              resp?.txId || resp?.txid || resp?.revealTxId || resp?.commitTxId ||
              (Array.isArray(resp?.txIds) ? resp.txIds[0] : null) ||
              (resp?.result && (resp.result.txId || resp.result.txid));
            if (!id) { setStatus('Wallet returned no txid.'); btn.disabled = false; return; }
            $id('addressDisplay').innerHTML += `<div><strong>Transaction ID:</strong> ${id}</div>`;
            setStatus('Verifying payment…');
            const verifyToken = await getHCToken();
            const verifyRes = await fetch('/verify_and_store', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ txId: id, reservationId, filename: reservedFilename, hCaptchaToken: verifyToken })
            });
            const verify = await verifyRes.json();
            if (verify.ok) {
              setStatus('Verified ✔');
              await refreshSupply();
            } else {
              setStatus('Verification failed: ' + (verify.error || 'Unknown error'));
            }
            btn.disabled = false;
          },
          onCancel: () => {
            setStatusHTML(
              `Confirming..ฅ^•ﻌ•^ฅ Please Wait<br>
              <a href="https://x.com/nekonekobtc" target="_blank" rel="noopener noreferrer" style="
                display:inline-flex; align-items:center; gap:6px; margin-top:8px; padding:6px 10px; border-radius:8px; background:#000; color:#fff;
                font-weight:700; text-decoration:none; font-family:sans-serif;">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="white" viewBox="0 0 1200 1227" aria-hidden="true">
                  <path d="M714 519L1160 0h-109L670 409 399 0H0l468 681L0 1227h109l409-472 285 472h398z"/>
                </svg>
                Follow on X
              </a>`
            );
            btn.disabled = false;
          }
        });
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Error during mint.');
        $id('mintButton').disabled = false;
      }
    }

    // ===== Verify Mint for WL =====
    async function verifyMint(txId) {
      console.log('[WL] Verifying txId:', txId);
      $id('addressDisplay').innerHTML += `<div><strong>Transaction ID:</strong> ${txId}</div>`;
      setStatus('Verifying WL payment…');
      try {
        const verifyToken = await getHCToken();
        const verifyRes = await fetch('/verify_and_store', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ txId, reservationId, filename: reservedFilename, address: window.ordinalAddress, hCaptchaToken: verifyToken })
        });
        const verify = await verifyRes.json();
        if (verify.ok) {
          setStatus('WL Mint verified ✔');
          if (verify.blacklistedInscription) {
            $id('addressDisplay').innerHTML += `<div><strong>Used WL Inscription:</strong> ${verify.blacklistedInscription}</div>`;
          }
          await refreshSupply();
          const eligibilityToken = await getHCToken();
          const eligibilityRes = await fetch('/check_wl_eligibility', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ address: window.ordinalAddress, hCaptchaToken: eligibilityToken })
          });
          const eligibility = await eligibilityRes.json();
          console.log('[WL] Post-mint eligibility:', eligibility);
          if (eligibility.ok && eligibility.eligible) {
            $id('addressDisplay').innerHTML += `<div><strong>Remaining WL Inscriptions:</strong> ${eligibility.inscriptions.length}</div>`;
          } else {
            $id('addressDisplay').innerHTML += `<div><strong>Remaining WL Inscriptions:</strong> 0</div>`;
          }
        } else {
          console.log('[WL] Verification failed:', verify);
          setStatus('Verification failed: ' + (verify.error || 'Unknown error'));
        }
      } catch (err) {
        console.error(err);
        setStatus('Verification failed: ' + (err.message || 'Unknown error'));
      }
    }

    // ===== Pixel flyers =====
    async function createFlyers() {
      const container = $id('flyerContainer');
      const images = Array.from({ length: 8 }, (_, i) => `static/flyers/${i + 1}.png`);
      const scaleFactor = 4;
      for (const src of images) {
        try {
          const img = new Image();
          img.src = src;
          img.crossOrigin = 'anonymous';
          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = () => reject(new Error('Failed to load ' + src));
          });
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 32 * scaleFactor; canvas.height = 32 * scaleFactor;
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          const flyerImg = document.createElement('img');
          flyerImg.src = canvas.toDataURL('image/png');
          flyerImg.className = 'flyer';
          flyerImg.style.top = `${Math.random() * (window.innerHeight - 120)}px`;
          flyerImg.style.setProperty('--y', `${(Math.random() * 40 - 20)}px`);
          flyerImg.style.animationDelay = `${Math.random() * 12}s`;
          container.appendChild(flyerImg);
        } catch (err) { console.error(err); }
      }
    }

    // ===== Init =====
    document.addEventListener('DOMContentLoaded', () => {
      $id('claimWLButton').addEventListener('click', claimWL);
      $id('mintButton').addEventListener('click', startMintFlow);
      startSlideshow();
      refreshSupply();
      setInterval(refreshSupply, 15000);
      createFlyers();
    });

    // ===== Public Mint Countdown =====
    (async function setupPublicMintCountdownOnButton() {
      const btn = document.getElementById('mintButton');
      const pill = document.getElementById('mintEtaPill');
      if (!btn || !pill) return;
      async function fetchConfig() {
        try {
          const r = await fetch('/config', { cache: 'no-store' });
          if (!r.ok) throw new Error('config http ' + r.status);
          return await r.json();
        } catch {
          return { now: Math.floor(Date.now() / 1000), publicMintStartTs: 0, publicMintOpen: true };
        }
      }
      function formatETA(seconds) {
        if (seconds <= 0) return "Opening…";
        const d = Math.floor(seconds / 86400);
        seconds %= 86400;
        const h = Math.floor(seconds / 3600);
        seconds %= 3600;
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        const parts = [];
        if (d) parts.push(`${d}d`);
        if (h) parts.push(`${h}h`);
        if (m) parts.push(`${m}m`);
        parts.push(`${s}s`);
        return parts.join(" ");
      }
      function lockButton() {
        btn.disabled = true;
        btn.classList.add('opacity-60', 'pointer-events-none');
        pill.classList.add('show');
      }
      function unlockButton() {
        btn.disabled = false;
        btn.classList.remove('opacity-60', 'pointer-events-none');
        pill.classList.remove('show');
      }
      const cfg = await fetchConfig();
      const startTs = Number(cfg.publicMintStartTs || 0);
      if (cfg.publicMintOpen || !startTs) { unlockButton(); return; }
      lockButton();
      let serverNow = Number(cfg.now || Math.floor(Date.now() / 1000));
      function tick() {
        const remaining = startTs - serverNow;
        if (remaining <= 0) {
          unlockButton();
          document.querySelector('#mintButton .btn-label').textContent = "Mint";
          pill.style.display = "none";
          clearInterval(timer);
          return;
        }
        pill.textContent = `Opens in ${formatETA(remaining)}`;
        serverNow += 1;
      }
      tick();
      const timer = setInterval(tick, 1000);
      setInterval(async () => {
        try {
          const fresh = await fetchConfig();
          if (fresh.publicMintOpen) { unlockButton(); clearInterval(timer); }
          else if (typeof fresh.now === 'number') serverNow = fresh.now;
        } catch { }
      }, 60000);
    })();
  </script>
</body>

</html>