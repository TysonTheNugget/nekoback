<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Neko BTC — Mint</title>
  <!-- Local Sats-Connect bundle -->
  <script src="{{ url_for('static', filename='sats-connect-bundle.js') }}"></script>
  <style>
    :root { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial; }
    html, body { height: 100%; }
    body { margin:0; background:pink; color:#e6eefc; display:grid; place-items:center; }
    .container { text-align:center; width:min(92vw, 720px); }
    header h1 { margin:16px 0 6px; }
    .muted { opacity:.75; font-size:.9em; }
    .counter { margin-top:6px; font-weight:700; }
    .image-container {
      background:#0f1a2b; border:1px solid #1e2a44; border-radius:20px;
      box-shadow:0 10px 30px rgba(0,0,0,.25); margin:20px auto; display:grid;
      place-items:center; overflow:hidden; width:320px; height:320px;
    }
    #randomImage { width:100%; height:100%; object-fit:contain; image-rendering:pixelated; image-rendering:crisp-edges; transition:opacity .5s ease; }
    .btn { margin-top:14px; padding:12px 18px; border-radius:999px; border:1px solid #2b3b60; background:#1a2850; color:#e6eefc; font-weight:700; cursor:pointer; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    #status { margin-top:12px; min-height:1.2em; }
    .flyer-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      z-index: -1;
    }
    .flyer {
      position: absolute;
      width: 128px; /* Matches canvas size (32 * 4) */
      height: 128px;
      object-fit: contain;
      image-rendering: pixelated; /* Ensures crisp edges */
      animation: flyAcross 10s linear infinite;
    }
    @keyframes flyAcross {
      0% { transform: translateX(-120px); }
      100% { transform: translateX(calc(100vw + 120px)); }
    }
  </style>
</head>
<body>
<div class="flyer-container" id="flyerContainer"></div>
<div class="container">
  <header>
    <h1>Neko Neko</h1>
    <p class="muted">Mint Page</p>
    <div class="counter" id="supplyCounter">10,000 / 10,000</div>
  </header>
  <button id="mintButton" class="btn">Mint</button>
  <div class="image-container">
    <img id="randomImage" src="" alt="Neko">
  </div>
  <div id="addressDisplay"></div>
  <div id="status"></div>
</div>
<script>
let reservationId = null;
let reservedFilename = null;
let watchTimer = null;
let slideshowTimer = null;
const SLIDESHOW_MS = 5000;
const $id = (x) => document.getElementById(x);
function setStatus(msg) { $id('status').textContent = msg || ''; }
async function refreshSupply() {
  try {
    const r = await fetch('/supply');
    const j = await r.json();
    const remaining = j.remaining ?? 0;
    const total = j.total ?? 10000;
    $id('supplyCounter').textContent = `${remaining.toLocaleString()} / ${total.toLocaleString()}`;
  } catch {}
}
function fadeSwapImage(newUrl) {
  const img = $id('randomImage');
  img.style.opacity = '0';
  const onLoad = () => { img.style.opacity = '1'; img.removeEventListener('load', onLoad); };
  img.addEventListener('load', onLoad);
  img.crossOrigin = 'anonymous';
  img.src = newUrl;
}
async function slideshowTick() {
  try {
    const res = await fetch('/randomize', { method: 'POST' });
    if (!res.ok) throw new Error('Randomize HTTP ' + res.status);
    const response = await res.json();
    if (response.imageUrl) fadeSwapImage(response.imageUrl);
  } catch (_) { /* ignore */ }
}
function startSlideshow() {
  if (slideshowTimer) clearInterval(slideshowTimer);
  slideshowTimer = setInterval(slideshowTick, SLIDESHOW_MS);
  slideshowTick();
}
async function getImageAsBase64(url) {
  const res = await fetch(url, { cache: 'no-cache' });
  const blob = await res.blob();
  const buf = await blob.arrayBuffer();
  const bytes = new Uint8Array(buf);
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin);
}
async function watchReservation() {
  if (!reservationId) return;
  try {
    const r = await fetch('/reservation_status', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ reservationId })
    });
    const j = await r.json();
    if (!j.ok) return;
    if (!j.active) {
      clearInterval(watchTimer); watchTimer = null;
      setStatus('Reservation ended.');
      return;
    }
    if (j.used) {
      clearInterval(watchTimer); watchTimer = null;
      setStatus('Mint confirmed ✔');
      await refreshSupply();
      return;
    }
  } catch (_) { /* ignore */ }
}
async function startMintFlow() {
  const btn = $id('mintButton');
  try {
    setStatus('Picking a random Neko…');
    const randRes = await fetch('/randomize', { method: 'POST' });
    if (!randRes.ok) throw new Error('Randomize HTTP ' + randRes.status);
    const rand = await randRes.json();
    const filename = rand?.imageInfo?.background;
    const randomizedUrl = rand?.imageUrl;
    if (!filename) throw new Error('Randomize did not return a filename');
    setStatus('Reserving your Neko…');
    const holdRes = await fetch('/reserve_for_image', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'X-Client-Id': crypto.randomUUID() },
      body: JSON.stringify({ filename })
    });
    const hold = await holdRes.json();
    if (!hold.ok) throw new Error(hold.error || 'Reserve failed');
    reservationId = hold.reservationId;
    reservedFilename = hold.filename || filename;
    const reservedUrl = hold.imageUrl || randomizedUrl;
    if (watchTimer) clearInterval(watchTimer);
    watchTimer = setInterval(watchReservation, 10_000);
    await refreshSupply();
    setStatus('Preparing inscription…');
    const prepRes = await fetch('/prepare_inscription', { method: 'POST' });
    const prep = await prepRes.json();
    if (!prep.appFeeAddress || !prep.appFee) throw new Error('Server missing app fee config');
    if (!window.SatsConnect || typeof window.SatsConnect.createInscription !== 'function') {
      setStatus('Sats-Connect not available. Check sats-connect-bundle.js.');
      btn.disabled = false; return;
    }
    if (!reservedUrl) throw new Error('Reserved image URL missing');
    const base64Image = await getImageAsBase64(reservedUrl);
    setStatus('Opening wallet…');
    await window.SatsConnect.createInscription({
      payload: {
        network: { type: prep.network || 'Mainnet' },
        contentType: 'image/png',
        content: base64Image,
        payloadType: 'BASE_64',
        appFeeAddress: prep.appFeeAddress,
        appFee: prep.appFee
      },
      onFinish: async (resp) => {
        const id =
          resp?.txId || resp?.txid || resp?.revealTxId || resp?.commitTxId ||
          (Array.isArray(resp?.txIds) ? resp.txIds[0] : null) ||
          (resp?.result && (resp.result.txId || resp.result.txid));
        if (!id) { setStatus('Wallet returned no txid.'); btn.disabled = false; return; }
        $id('addressDisplay').innerHTML = `<div>Transaction ID: ${id}</div>`;
        setStatus('Verifying payment…');
        const verifyRes = await fetch('/verify_and_store', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ txId: id, reservationId, filename: reservedFilename })
        });
        const verify = await verifyRes.json();
        if (verify.ok) {
          setStatus('Verified ✔');
          await refreshSupply();
        } else {
          setStatus('Verification failed: ' + (verify.error || 'Unknown error'));
        }
        btn.disabled = false;
      },
      onCancel: () => {
        setStatus('Confirming..');
        btn.disabled = false;
      }
    });
  } catch (err) {
    console.error(err);
    setStatus(err.message || 'Error during mint.');
    $id('mintButton').disabled = false;
  }
}
async function createFlyers() {
  const container = $id('flyerContainer');
  const images = Array.from({length: 8}, (_, i) => `static/flyers/${i + 1}.png`);
  const scaleFactor = 1.1; // Upscale 32x32 to 128x128 (4x)

  for (const src of images) {
    try {
      // Create image element and load the source
      const img = new Image();
      img.src = src;
      img.crossOrigin = 'anonymous'; // If images are served from a different origin

      // Wait for the image to load
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
      });

      // Create a canvas to upscale the image
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 32 * scaleFactor; // New width (128px)
      canvas.height = 32 * scaleFactor; // New height (128px)

      // Disable image smoothing to preserve pixel art look
      ctx.imageSmoothingEnabled = false;

      // Draw the original 32x32 image scaled up
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      // Create a new image element for the flyer
      const flyerImg = document.createElement('img');
      flyerImg.src = canvas.toDataURL('image/png'); // Use upscaled image as data URL
      flyerImg.className = 'flyer';
      flyerImg.style.top = `${Math.random() * (window.innerHeight - 100)}px`;
      flyerImg.style.animationDelay = `${Math.random() * 10}s`;
      flyerImg.style.width = `${100 * scaleFactor}px`; // Adjust size for display (128px)
      flyerImg.style.height = `${100 * scaleFactor}px`; // Adjust size for display (128px)

      // Optional: Add pixelated rendering for browsers
      flyerImg.style.imageRendering = 'pixelated';

      // Append to container
      container.appendChild(flyerImg);
    } catch (err) {
      console.error(err);
    }
  }
}
document.addEventListener('DOMContentLoaded', () => {
  $id('mintButton').addEventListener('click', startMintFlow);
  startSlideshow();
  refreshSupply();
  setInterval(refreshSupply, 15000);
  createFlyers();
});
</script>
</body>
</html>